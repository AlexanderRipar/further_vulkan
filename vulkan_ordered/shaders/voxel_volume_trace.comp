#version 450
#extension GL_ARB_separate_shader_objects : enable





layout (local_size_x_id = 1) in;
layout (local_size_y_id = 2) in;
layout (local_size_x = 8, local_size_y = 8) in;

layout (constant_id = 3) const uint BASE_DIM_LOG2 = 6;
layout (constant_id = 4) const uint BRICK_DIM_LOG2 = 3;
layout (constant_id = 5) const uint LEVEL_CNT = 1;

layout (set = 0, binding = 0, rgba8) uniform coherent writeonly image2D hit_ids;

layout (set = 0, binding = 1, r32f) uniform coherent writeonly image2D hit_times;

layout (set = 0, binding = 2, r16ui) uniform readonly uimage3D base_data;

layout (set = 0, binding = 3) readonly buffer Bricks {
	uint elems[];
} bricks;

layout (set = 0, binding = 4) readonly buffer Leaves {
	uint elems[];
} leaves;

layout(push_constant) uniform Push_data {
	vec3 origin;
	vec2 direction_delta;
	mat3 direction_rotation;
} push_data;





vec3 calculate_direction(in vec2 invocation, in vec2 render_extent)
{
	vec2 invocation_centered = vec2(invocation) - render_extent * 0.5 + 0.5;

	vec3 base_direction = vec3(push_data.direction_delta * invocation_centered, -1.0);

	vec3 normalized_direction = normalize(base_direction);

	return normalized_direction * push_data.direction_rotation;
}

void main()
{
	// Check if we are inside the image

	ivec2 invocation = ivec2(gl_GlobalInvocationID.xy);

	ivec2 render_extent = imageSize(hit_ids);

	if (invocation.x > render_extent.x || invocation.y > render_extent.y)
		return;



	// Get ray parameters

	vec3 ray_direction = calculate_direction(invocation, render_extent);
	
	vec3 ray_direction_reciprocal = 1.0 / ray_direction;

	ivec3 current_base_idx = ivec3(push_data.origin);

	vec3 ray_offset = (vec3(greaterThanEqual(ray_direction, vec3(0.0))) - push_data.origin) * ray_direction_reciprocal;

	vec3 ray_coefficient = ray_direction_reciprocal;

	ivec3 ray_sign = ivec3(sign(ray_direction));



	vec3 ray_time;

	float min_time = -1.0;

	int base_offset = 1 << (BASE_DIM_LOG2 - 1);

	int base_level = 0;

	ivec3 abs_current_base_idx = abs(current_base_idx);

	

	// Start a-looping

	while(base_offset < 1 << (BASE_DIM_LOG2 * LEVEL_CNT))
	{
		while (max(max(abs_current_base_idx.x, abs_current_base_idx.y), abs_current_base_idx.z) < base_offset * 2)
		{
			ivec3 image_idx = ivec3(base_level * BASE_DIM_LOG2 + current_base_idx.x >> base_level, current_base_idx.y >> base_level, current_base_idx.z >> base_level) + ivec3(base_offset);

			uint base_value = imageLoad(base_data, current_base_idx + base_offset).x;

			if (base_value != 0xFFFF)
			{
				vec3 last_step;

				if(min_time == -1.0)
					last_step = vec3(0.6, 0.25, 0.1);
				else if(min_time == ray_time.x)
					last_step = vec3(0.75, 0.25, 0.25);
				else if(min_time == ray_time.y)
					last_step = vec3(0.25, 0.75, 0.25);
				else
					last_step = vec3(0.25, 0.25, 0.75);

				imageStore(hit_ids, invocation, vec4(last_step, 1.0));

				imageStore(hit_times, invocation, vec4(min_time));

				return;
			}
			
			ray_time = ray_coefficient * vec3(current_base_idx) + ray_offset;

			min_time = min(min(ray_time.x, ray_time.y), ray_time.z);

			if (min_time == ray_time.x)
				current_base_idx.x += ray_sign.x;
			else if (min_time == ray_time.y)
				current_base_idx.y += ray_sign.y;
			else
				current_base_idx.z += ray_sign.z;
		}

		base_offset *= 2;

		ray_sign *= 2;
	}

	imageStore(hit_ids, invocation, vec4(0.0, 0.1, 0.2, 1.0));

	imageStore(hit_times, invocation, vec4(intBitsToFloat(0x7F800000)));
}

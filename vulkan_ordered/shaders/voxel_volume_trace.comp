#version 450
#extension GL_ARB_separate_shader_objects : enable





layout (local_size_x_id = 1) in;
layout (local_size_y_id = 2) in;
layout (local_size_x = 8, local_size_y = 8) in;

layout (constant_id = 3) const uint BASE_DIM_LOG2 = 6;
layout (constant_id = 4) const uint BRICK_DIM_LOG2 = 3;
layout (constant_id = 5) const uint LEVEL_CNT = 1;

layout (set = 0, binding = 0, rgba8) uniform coherent writeonly image2D hit_ids;

layout (set = 0, binding = 1, r32f) uniform coherent writeonly image2D hit_times;

layout (set = 0, binding = 2, r16ui) uniform readonly uimage3D base_data;

layout (set = 0, binding = 3) readonly buffer Bricks {
	uint elems[];
} bricks;

layout (set = 0, binding = 4) readonly buffer Leaves {
	uint elems[];
} leaves;

layout(push_constant) uniform Push_data {
	vec3 origin;
	vec2 direction_delta;
	mat3 direction_rotation;
} push_data;





vec3 calculate_direction(in vec2 invocation, in vec2 render_extent)
{
	vec2 invocation_centered = vec2(invocation) - render_extent * 0.5 + 0.5;

	vec3 base_direction = vec3(push_data.direction_delta * invocation_centered, -1.0);

	vec3 normalized_direction = normalize(base_direction);

	return normalized_direction * push_data.direction_rotation;
}

vec3 calculate_initial_ray_time(vec3 ray_direction_reciprocal)
{
	vec3 negative_adjustment = vec3(ray_direction_reciprocal.x < 0.0, ray_direction_reciprocal.y < 0.0, ray_direction_reciprocal.z < 0.0);

	vec3 offset = fract(negative_adjustment - push_data.origin.xyz);

	return offset * ray_direction_reciprocal;
}

void main()
{
	// Check if we are inside the image

	ivec2 invocation = ivec2(gl_GlobalInvocationID.xy);

	ivec2 render_extent = imageSize(hit_ids);

	if (invocation.x > render_extent.x || invocation.y > render_extent.y)
		return;



	// Get ray parameters

	vec3 ray_direction = calculate_direction(invocation, render_extent);
	
	vec3 ray_direction_reciprocal = 1.0 / ray_direction;

	ivec3 current_base_idx = ivec3(push_data.origin);

	vec3 collision_planes = floor(push_data.origin) + vec3(greaterThanEqual(ray_direction, vec3(0.0)));

	vec3 ray_collision_offset = -push_data.origin * ray_direction_reciprocal;





	vec3 ray_step = abs(ray_direction_reciprocal);

	ivec3 ray_sign = ivec3(sign(ray_direction));

	vec3 ray_time = calculate_initial_ray_time(ray_direction_reciprocal);
	
	uint value_at_pos = imageLoad(base_data, current_base_idx).x;

	vec3 last_step = vec3(0.5, 0.3, 0.2);

	// Start a-looping

	while (max(max(uint(current_base_idx.x), uint(current_base_idx.y)), uint(current_base_idx.z)) < 1 << BASE_DIM_LOG2)
	{
		float min_time = min(min(ray_time.x, ray_time.y), ray_time.z);

		uint brick_value = imageLoad(base_data, current_base_idx).x;

		if (brick_value != 0xFFFF)
		{
			float brick_value_flt = float(brick_value) / 256.0;

			imageStore(hit_ids, invocation, vec4(last_step, 1.0));

			imageStore(hit_times, invocation, vec4(min_time));

			return;
		}

		if (min_time == ray_time.x)
		{
			ray_time.x += ray_step.x;
			current_base_idx.x += ray_sign.x;

			last_step = vec3(0.75, 0.25, 0.25);
		}
		else if (min_time == ray_time.y)
		{
			ray_time.y += ray_step.y;
			current_base_idx.y += ray_sign.y;
			
			last_step = vec3(0.25, 0.75, 0.25);
		}
		else
		{
			ray_time.z += ray_step.z;
			current_base_idx.z += ray_sign.z;
			
			last_step = vec3(0.25, 0.25, 0.75);
		}
	}

	imageStore(hit_ids, invocation, vec4(0.0, 0.1, 0.2, 1.0));

	imageStore(hit_times, invocation, vec4(intBitsToFloat(0x7F800000)));
}
